## Version 3 — Hardened Integrated Prompt (Design B, Repo-Resident Orchestrator State)

Prerequisites (hard requirements)
- Codex CLI is installed and authenticated.
- Run inside a Git repository (required for diff/revert hygiene and deterministic enforcement).
- Python 3.11+ available.

Compatibility note (do not hand-wave)
- This workflow references optional Codex flags such as:
  - --experimental-json (JSONL event stream)
  - --output-schema (schema-constrained output)
- The orchestrator MUST implement feature detection:
  - Check support deterministically by invoking `codex exec --help` and string-matching for the flags.
  - If unsupported, the orchestrator MUST proceed without them (still fully functional), and MUST NOT pretend they were used.
- Regardless of flag support, gating/learning MUST rely on filesystem + validators + exit codes only.

Goal
Build a Codex-only, multi-run “multi-agent” software creation workflow driven by a single Python script.

Hard constraints
- The Python orchestrator must NOT call the OpenAI API and must NOT use any Codex SDK.
- The orchestrator MUST orchestrate multiple `codex exec` subprocess runs with different role prompts (“agents”).
- Codex MUST be responsible for authoring/updating project files in the workspace.
- The orchestrator controls progression via deterministic gating (validators, diffs, hashes, exit codes).
- “Learning” is allowed only as deterministic policy updates and deterministic prompt/skill evolution (no model training).

Required deliverables (Codex-authored unless stated otherwise)
Codex MUST create/update these exact paths (case-sensitive):
- REQUIREMENTS.md
- TEST.md
- AGENT_TASKS.md
- directories: /design, /frontend, /backend, /tests

Design B additional required deliverables
- AGENTS.md (repo root; stable instructions for all Codex runs; becomes locked after bootstrap)
- directories:
  - /prompts              (prompt templates/variants; editable ONLY by Prompt Library Bootstrap/Prompt Tuner step)
  - /.codex/skills        (skill library; editable ONLY by Prompt Library Bootstrap/Prompt Tuner step)

Orchestrator private state (Python-authored only; in-repo; NOT product deliverables)
- The Python orchestrator MAY create and maintain: /.orchestrator/
  - /.orchestrator/policy.json
  - /.orchestrator/runs/<run_id>/**   (immutable run logs: manifests, diffs, validator reports)
  - /.orchestrator/evals/<run_id>.json
  - /.orchestrator/cache/** (optional)
- Codex MUST NEVER modify anything under /.orchestrator/** (hard invariant).
- The orchestrator MUST enforce this invariant (see “Boundary Enforcement” below).

Non-negotiable invariants (hard-fail if violated)
1) Codex may not modify /.orchestrator/** at any time.
2) Codex may not modify .git/** at any time.
3) Each step must only modify allowlisted paths for that step.
4) If allowlist violation occurs, the step is failed and changes are reverted deterministically.
5) A step may only be marked successful if all validators for that step pass.
6) Retries are bounded: max_attempts_per_step = 3 (1 initial + up to 2 retries). No infinite loops.
7) Prompt Tuner/Prompt Library Bootstrap may ONLY modify /prompts/** and /.codex/skills/** (and nothing else).
8) After bootstrap, AGENTS.md becomes locked: no step (including Prompt Tuner) may modify it.

Boundary Enforcement (do NOT skip; this closes the v2 trust gap)
- The orchestrator must never “ignore diffs under /.orchestrator/**”.
- Instead, it MUST enforce:
  A) “No orchestrator writes during a Codex run window.”
     - Before launching codex exec for a step:
       - capture a PRE snapshot of file hashes for:
         - all tracked files AND all files under /.orchestrator/** AND all allowlisted areas (minimum)
       - optionally chmod /.orchestrator/** to read-only on POSIX (extra guardrail).
     - Run codex exec.
     - Immediately after codex returns (BEFORE the orchestrator writes any logs/policy files):
       - capture a POST snapshot
       - compute changed paths and enforce allowlists + forbidden paths
  B) Only after gating passes/fails and any reverts are done, the orchestrator may write to /.orchestrator/**.
  C) If /.orchestrator/** changed between PRE and POST snapshots during the Codex window, that step hard-fails and changes are reverted.

Agent model (two-layer design)
1) Orchestrator / Project Manager (Python)
- Break work into steps, run specialists, enforce gating, manage retries.
- Maintain deterministic “learning” state in /.orchestrator/policy.json.
- Implement Design B evals loop for prompt/skill library evolution with strict guardrails.

2) Specialists (each is one `codex exec` run)
- Each specialist has:
  - a role prompt
  - a file allowlist (writable paths)
  - validators
- Specialists should be run sequentially by default.

Pipeline steps (default order; deterministic)
0) Bootstrap / Release Engineer
   - Purpose: establish repo instructions, required directories, and run commands.
   - Outputs: AGENTS.md + required dirs (/design, /frontend, /backend, /tests) + baseline docs skeletons if missing.
   - After this step, AGENTS.md becomes LOCKED.

1) Requirements Analyst
2) UX / Designer
3) Frontend Dev
4) Backend Dev
5) QA Tester
6) Docs Writer

Design B: Prompt Library Bootstrap + Prompt Tuner (special steps)
- Prompt Library Bootstrap:
  - Run ONLY if /prompts/** or /.codex/skills/** is missing or empty.
  - Allowlist is ONLY: /prompts/** and /.codex/skills/**
  - Creates initial prompt variants (2–5 per agent) and initial skill files.
- Prompt Tuner:
  - Optional optimization loop after a baseline pipeline run and scoring.
  - Allowlist is ONLY: /prompts/** and /.codex/skills/**
  - Accepted only if deterministic score strictly improves and invariants hold.

Codex invocation protocol (hard requirements)
- The orchestrator launches `codex exec` as a subprocess.
- The prompt MUST be provided via stdin (`-`).
- The orchestrator captures stdout + stderr.
- If available, `--experimental-json` MAY be enabled for diagnostics only.
- The orchestrator MAY store JSONL event streams in /.orchestrator/runs/** for debugging.
- The orchestrator MUST NOT use natural-language output (stdout/stderr text, event text) for gating or learning.
  - Gating/Learning inputs are ONLY:
    - validator pass/fail and validator error codes
    - filesystem diffs (changed paths)
    - hashes/manifests
    - exit codes

Filesystem allowlists (global + per-step)
- Global forbidden paths for Codex (hard fail if touched):
  - /.orchestrator/**
  - /.git/**
- Global restricted paths (allowed only for specific steps if explicitly allowlisted):
  - /prompts/** and /.codex/skills/** (ONLY Prompt Library Bootstrap/Prompt Tuner)
  - AGENTS.md (ONLY step 0 Bootstrap/Release Engineer; then locked)
- Each step has a per-step allowlist of writable paths.
  Example minimal allowlists:
  - Step 0 Bootstrap: AGENTS.md, REQUIREMENTS.md, TEST.md, AGENT_TASKS.md, /design/**, /frontend/**, /backend/**, /tests/**
  - Requirements: REQUIREMENTS.md, AGENT_TASKS.md
  - Designer: /design/**, REQUIREMENTS.md (optional)
  - Frontend: /frontend/**, /tests/** (frontend tests), TEST.md (optional)
  - Backend: /backend/**, /tests/** (backend tests), TEST.md (optional)
  - QA: /tests/**, TEST.md
  - Docs: REQUIREMENTS.md, TEST.md, AGENT_TASKS.md
- The orchestrator MUST verify:
  - No file outside the allowlist changed during that Codex run window.
  - No deletions occurred unless deletions are explicitly allowed for that step.
  - Total changed files and bytes are within limits.

Change limits (deterministic safety)
- Default per-step caps:
  - max_changed_files = 60
  - max_total_bytes_changed = 500_000
  - max_deleted_files = 0 (unless step explicitly allows deletions)
- If caps exceeded, step fails, changes revert, retry with a stricter patch.

Deterministic validators (minimum viable but explicit)
1) Existence + structure
- Required files exist exactly:
  - REQUIREMENTS.md, TEST.md, AGENT_TASKS.md, AGENTS.md
- Required directories exist:
  - /design, /frontend, /backend, /tests

2) Content validators (deterministic string/regex checks)
REQUIREMENTS.md must contain headings:
- "# Overview"
- "# Scope"
- "# Non-Goals"
- "# Acceptance Criteria"
- "# Risks"

TEST.md must contain:
- "# How to run tests"
- A fenced code block with at least ONE command
- A section "# Environments"

AGENT_TASKS.md must contain:
- "# Agent Tasks"
- A section per specialist role used (minimum: Requirements, Designer, Frontend, Backend, QA)
- Each section contains at least 2 bullet tasks

AGENTS.md must contain:
- "# Global Rules"
- "# File Boundaries"
- "# How to Run Tests"
- An explicit rule: "Do not modify /.orchestrator/**"
- After step 0 completes, AGENTS.md is LOCKED (no further modification allowed).

3) Test execution validators
- The orchestrator runs deterministic test commands extracted from TEST.md:
  - Take the FIRST fenced code block under "# How to run tests"
  - Execute commands line-by-line (skip blanks and lines starting with "#")
- If extraction fails, validator fails with error code (e.g., TEST_CMD_MISSING).
- Tests pass only if exit code == 0.

Deterministic scoring (Design B; exact function)
- Scoring is computed ONLY after the pipeline (and after any fixers/retries).
- Hard invalidation: if any hard invariant fails, score = -1 and run is invalid.
- Otherwise:
  score = 0
  +40 if all required files/dirs exist
  +30 if all content validators pass
  +30 if tests pass (exit code 0)
  -5  per retry beyond the first attempt across all steps (total retries)
  -10 per fixer run executed
  -1  per changed file above 20 total (soft penalty)
- Score floor: minimum 0 (except hard invalidation uses -1).

Learning (Orchestrator-only, always; deterministic)
- Maintain /.orchestrator/policy.json with:
  - per-step + per-variant stats: attempts, passes, clean_passes, failures by error_code
  - per-error deterministic “constraint patches” as bounded strings (max 8 lines total per step)
  - per-step limits overrides (may only tighten safety, never loosen)
  - variant selection configuration (see below)
- Policy updates MUST be deterministic functions of:
  - validator error codes
  - allowlist violations
  - exit codes
  - diff stats (file counts, byte deltas)
  - retry counts
- The orchestrator MUST NOT derive policy from interpreting Codex natural-language output.

Prompt-library epoching (critical for Design B)
- The orchestrator MUST compute a deterministic prompt_epoch_id:
  - prompt_epoch_id = sha256 hash over the contents of:
    - /prompts/**
    - /.codex/skills/**
  - (e.g., hash of concatenated file paths + file bytes in sorted path order)
- Variant performance stats MUST be tracked per (agent_role, prompt_epoch_id).
- If prompt_epoch_id changes (e.g., Prompt Tuner accepted changes), the orchestrator MUST:
  - start a new stats bucket for that epoch
  - return to BOOTSTRAP selection for that role (round-robin until enough samples)

Prompt variants + deterministic selection (replaces epsilon-greedy)
- Store 2–5 prompt templates per agent role in /prompts/<agent>/.
- Variant list order is deterministic: sort by relative path (lexicographic).
- Selection is a deterministic 2-phase procedure per (agent_role, prompt_epoch_id):

Definitions (deterministic)
- attempts[v] = number of times variant v has been used for that role in that epoch
- pass[v] = step validators passed (1/0)
- clean_pass[v] = validators passed AND retries_used == 0 AND fixer_runs == 0 (1/0)
- mean_clean[v] = clean_pass[v] / max(1, attempts[v])
- total_attempts = sum(attempts[v]) over active variants

Phase 1: BOOTSTRAP (deterministic round-robin)
- Bootstrap completion condition (“enough samples”):
  - bootstrap_min_trials_per_variant = 3 (configurable, deterministic; default 3)
  - BOOTSTRAP is complete only when every active variant has attempts[v] >= bootstrap_min_trials_per_variant.
- While in BOOTSTRAP:
  - choose the next variant in round-robin order:
    - rr_index = (last_rr_index + 1) mod len(active_variants_sorted)
    - pick active_variants_sorted[rr_index]
  - update last_rr_index deterministically in policy.json for that role+epoch

Phase 2: AFTER BOOTSTRAP (choose ONE deterministic strategy)
- The orchestrator MUST support these strategies; configured in policy.json under:
  selection_strategy in {"ucb1", "explore_then_commit", "rr_elimination"}
- Default selection_strategy = "ucb1" (deterministic; no randomness).

Strategy A: deterministic UCB1 (ucb1)
- Parameter: ucb_c = 1.0 (configurable; deterministic)
- For each active variant v:
  ucb_score[v] = mean_clean[v] + ucb_c * sqrt( ln(max(1, total_attempts)) / max(1, attempts[v]) )
- Choose v with maximum ucb_score[v].
- Tie-breaker: pick lexicographically smallest variant path.

Strategy B: explore-then-commit (explore_then_commit)
- After BOOTSTRAP, compute best variant:
  best = argmax_v(mean_clean[v]) with lexicographic tie-break.
- Commit window:
  - commit_window_runs = 10 (configurable)
  - For the next commit_window_runs selections, always choose best.
- Deterministic re-explore triggers:
  - Track consecutive_failures_best (validators fail OR retries_used>0 OR fixer_runs>0 counts as not-clean).
  - If consecutive_failures_best >= 2 OR mean_clean[best] drops below 0.3 after >= 10 attempts:
    - exit commit mode and re-enter BOOTSTRAP for that role+epoch (reset last_rr_index but keep stats)

Strategy C: round-robin with elimination (rr_elimination)
- Continue deterministic round-robin, but maintain an eliminated set per role+epoch.
- Elimination parameters (configurable; deterministic defaults):
  - elim_min_trials = 6
  - elim_min_mean_clean = 0.1
  - elim_max_failure_rate = 0.9  (failure_rate = 1 - pass[v]/attempts[v])
- If attempts[v] >= elim_min_trials AND (mean_clean[v] < elim_min_mean_clean OR failure_rate[v] > elim_max_failure_rate):
  - mark v eliminated and remove from active set
- If all variants are eliminated:
  - clear eliminated set and re-enter BOOTSTRAP (deterministic recovery)

Selection determinism requirements (hard)
- No randomness anywhere in selection.
- All tie-breaks must be deterministic (lexicographic).
- All parameters must live in policy.json with explicit defaults.
- Every selection decision must be logged deterministically under /.orchestrator/runs/** (after the Codex window ends).

Design B: Prompt Library Bootstrap & Prompt Tuner (guardrailed)
Prompt Library Bootstrap (only if needed)
- Condition: /prompts/** missing/empty OR /.codex/skills/** missing/empty
- Step allowlist: ONLY /prompts/** and /.codex/skills/**
- Must create:
  - /prompts/<agent>/*.txt (2–5 variants per agent)
  - /.codex/skills/<agent>/SKILL.md (YAML front matter + body)
- Must not modify any other path.

Prompt Tuner (optional outer loop)
High-level loop (must be implemented in Python)
1) Run baseline pipeline with current prompts/skills.
2) Compute baseline score and store /.orchestrator/evals/<run_id>.json.
3) Run Prompt Tuner (one codex exec run) with allowlist restricted to:
   - /prompts/**
   - /.codex/skills/**
4) Validate tuner changes with deterministic guardrails (below).
5) Recompute score in a controlled regression:
   - Preferred: re-run only failing steps OR steps whose role prompts changed materially
     (deterministically: variant file hash changes under /prompts/<agent>/ or skills hash changes).
   - Otherwise: re-run full pipeline.
6) Accept tuner changes ONLY IF:
   - tuned_score > baseline_score (strict)
   - AND invariants hold (no forbidden paths touched, no allowlist violations, AGENTS.md unchanged, validators pass)
   - Else revert prompt/skill changes deterministically (git restore) and keep baseline.

Prompt/skill guardrail validators (hard requirements)
- For /.codex/skills/<agent>/SKILL.md:
  - Must start with YAML front matter (--- ... ---)
  - Required keys: name, description
  - Max file size: 64 KB
  - Forbidden substrings (case-insensitive) must NOT appear:
    - "ignore validators"
    - "bypass allowlists"
    - "write outside allowed paths"
    - "mark step as done even if tests fail"
    - "modify .orchestrator"
- For /prompts/** templates:
  - Max file size: 64 KB
  - Forbidden substrings list above must NOT appear
  - Prompts must not instruct proceeding on failure or disabling gating

Fixer runs (narrow, deterministic)
- A fixer run is a codex exec step with a minimal prompt focused on one deterministic failure.
- Fixer allowlist must be minimal and derived from the failure type.
- Fixers are bounded and counted (penalized in scoring).

Implementation constraints (for Codex to implement)
- Deliver a single runnable Python script at repo root named: orchestrator.py
- Prefer Python stdlib only.
- Clear logging to console; machine-readable logs under /.orchestrator/runs/**.
- Orchestrator must never author product source files directly; exceptions allowed ONLY for deterministic reverts:
  - git restore/checkout to revert unauthorized changes or to revert rejected prompt-tuner edits.

What Codex must NOT do
- Do not claim completion based on narrative text.
- Do not rely on natural-language summaries for gating.
- Do not modify forbidden paths.
- Do not introduce infinite loops or unbounded retries.

What Codex must DO
- Implement orchestrator.py meeting all requirements above.
- Ensure exact required files/dirs exist.
- Enforce strict boundaries: no Codex writes to /.orchestrator/** during Codex windows, and never ignore those diffs.
